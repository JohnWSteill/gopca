# Copyright (c) 2015, 2016 Florian Wagner
#
# This file is part of GO-PCA.
#
# GO-PCA is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""Module containing the `GOPCASignatureMatrix` class.
"""

from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from builtins import *

import logging
import hashlib
import copy
from collections import Iterable

import six
import pandas as pd
import numpy as np

from genometools.expression import ExpMatrix
from genometools.expression import cluster
from genometools.expression.visualize import ExpHeatMap, HeatMapGeneAnnotation

# from .config import GOPCAConfig
from . import GOPCASignature
# from gopca import util

if six.PY2:
    import cPickle as pickle
else:
    import pickle

logger = logging.getLogger(__name__)


class GOPCASignatureMatrix(object):
    """A GO-PCA signature matrix (the result of a GO-PCA run).

    Parameters
    ----------
    signatures: Iterable of `GOPCASignature`
        The signatures generated.
    samples: Iterable
        The samples in the analysis.
    """
    def __init__(self, signatures, samples):

        # type checks
        assert isinstance(signatures, Iterable)
        assert isinstance(samples, Iterable)

        self.signatures = list(signatures)
        self.samples = list(samples)

    # magic functions
    def __repr__(self):
        return ('<GOPCASignatureMatrix instance (q=%d, hash="%s")>'
                % (self.q, self.hash))

    def __str__(self):
        return ('<GOPCASignatureMatrix instance with %d signatures (n=%d)>'
                % (self.q, self.n))

    def __eq__(self, other):
        if self is other:
            return True
        elif type(self) is type(other):
            return repr(self) == repr(other)
        else:
            return NotImplemented

    def __ne__(self, other):
        return not self.__eq__(other)

    @property
    def hash(self):
        """An MD5 hash string for the signature."""
        data_str = ';'.join([
            str(repr(var)) for var in
            [self.samples, self.signatures]
        ])
        data = data_str.encode('UTF-8')
        return str(hashlib.md5(data).hexdigest())

    @property
    def n(self):
        """The number of samples in the matrix."""
        return len(self.samples)

    @property
    def q(self):
        """The number of signatures in the matrix."""
        return len(self.signatures)

    def get_signature(self, name, pc=None, i=None):
        """Look up a signature by name, PC, and index.

        """
        # TODO: Finish docstring.
        # find all signatures that start with name and (optionally)
        # were generated by a certain PC

        # type checks
        assert isinstance(name, str)
        if pc is not None:
            assert isinstance(pc, int) and pc >= 1
        if i is not None:
            assert isinstance(i, int)

        if i is None:
            i = 0

        found = []
        for sig in self.signatures:
            if sig.gene_set.name.startswith(name):
                if pc is None or abs(sig.pc) == pc:
                    found.append(sig)

        if not found:
            raise ValueError('Signature not found!')

        if i >= len(found):
            raise ValueError('Index "%d" out of bounds.' % i)

        return found[i]

    @property
    def signature_labels(self):
        """The list of signature labels."""
        sig_labels = self.get_signature_labels()
        return sig_labels

    @property
    def expression_matrix(self):
        """An `ExpMatrix` representation of the signature matrix."""
        return self.get_expression_matrix()

    def get_signature_labels(self, max_name_length=50, include_id=False):
        """Returns the list of GO-PCA signature labels.

        Parameters
        ----------
        max_name_length: int, optional
            The maximal number of characters for each label. Labels that are
            too long are truncated (indicated by "..."). [50]
        include_id: bool, optional
            Whether to include the gene set ID in the label. [False]

        Returns
        -------
        list of str
            The signature labels.
        """
        sig_labels = [
            sig.get_label(max_name_length=max_name_length,
                          include_id=include_id)
            for sig in self.signatures
        ]
        return sig_labels

    def get_expression_matrix(
            self,
            standardize=False,
            center=True,
            use_median=True,
            cluster_signatures=True,
            signature_cluster_metric='correlation',
            cluster_samples=True,
            sample_cluster_metric='euclidean',
            cluster_method='average'
        ):
        """Returns the GO-PCA signature matrix.

        The GO-PCA signature matrix contains the expression levels of all
        signatures (rows) generated, across all samples (columns) in the
        analysis. See the documentation of the `GOPCASignature` class for
        details on how signature expression levels are calculated.

        Parameters
        ----------
        max_name_length: int, optional
            The maximal number of characters for each label. Labels that are
            too long are truncated (indicated by "..."). [50]
        include_id: bool, optional
            Whether to include the gene set ID in the label. [False]

        Returns
        -------
        `genometools.expression.ExpMatrix`
            The signature matrix.
        """
        # TODO: finish docstring
        assert isinstance(standardize, bool)
        assert isinstance(center, bool)
        assert isinstance(use_median, bool)
        assert isinstance(cluster_signatures, bool)
        assert isinstance(cluster_samples, bool)

        # generate the expression matrix
        matrix = pd.concat(
            [sig.get_expression(
                standardize=standardize, center=center, use_median=use_median
             ).to_frame()
             for sig in self.signatures],
            axis = 1
        ).T

        # clustering
        if cluster_signatures:
            # cluster signatures
            matrix = cluster.cluster_genes(
                matrix, metric=signature_cluster_metric, method=cluster_method
            )

        order_samples = None
        if cluster_samples:
            # cluster samples
            matrix = cluster.cluster_samples(
                matrix, metric=sample_cluster_metric, method=cluster_method
            )

        assert isinstance(matrix, ExpMatrix)
        return matrix

    def get_heatmap(
            self, max_name_length=50, include_id=False,
            highlight_sig=None, highlight_source=None,
            emin=-3.0, emax=3.0,
            font_size=12, title_font_size=16,
            margin_left=150, margin_bottom=50,
            show_sample_labels=False,
            sig_matrix_kw=None, **kwargs):
        """Generate a plotly heatmap showing the GO-PCA signature matrix."""

        if sig_matrix_kw is None:
            sig_matrix_kw = {}

        if highlight_sig is None:
            highlight_sig = {}

        if highlight_source is None:
            highlight_source = {}

        assert isinstance(highlight_source, dict)
        assert isinstance(sig_matrix_kw, dict)

        # plot heat map
        cb_label = kwargs.pop('colorbar_label', None)
        if cb_label is None:
            cb_label = 'Expression'

        # generate expresssion matrix
        matrix = self.get_expression_matrix(**sig_matrix_kw)

        # generate signature labels
        signatures = matrix.index.values
        sig_labels = [
            sig.get_label(max_name_length=max_name_length,
                          include_id=include_id)
            for sig in signatures
        ]

        # add signature annotations
        sig_annotations = []

        # annotations for individual signatures
        for sig, color in highlight_sig.items():
            try:
                # pd.Index.get_loc() does not work with objects (bug?), so
                # we have to do it the slow way using np.nonzero
                i = np.nonzero(matrix.genes == sig)[0][0]
                sig_annotations.append(
                    HeatMapGeneAnnotation(sig_labels[i], color, sig_labels[i])
                )
            except KeyError as e:
                raise e
                # raise ValueError('%s not found in signature matrix.'
                #                  % str(sig))

        # annotations for all signatures from certain gene set sources
        for src, color in highlight_source.items():
            for sig, label in zip(matrix.index, sig_labels):
                if sig.gene_set.source == src:
                    sig_annotations.append(
                        HeatMapGeneAnnotation(label, color, label)
                    )

        # replace signatures with labels in expression matrix
        matrix.index = sig_labels

        # initialize ExpHeatMap
        heatmap = ExpHeatMap(matrix, gene_annotations=sig_annotations)

        fig = heatmap.get_figure(
            yaxis_label='Signatures',
            colorbar_label=cb_label,
            emin=emin, emax=emax,
            show_sample_labels=show_sample_labels,
            font_size=font_size, title_font_size=title_font_size,
            margin_left=margin_left, margin_bottom=margin_bottom,
            **kwargs
        )

        return fig

    def filter_signatures(self, corr_thresh, inplace=False):
        """Remove "redundant" signatures."""

        # checks
        assert isinstance(corr_thresh, (float, int))
        assert 0 < corr_thresh <= 1.0

        sig_matrix = self
        if not inplace:
            sig_matrix = copy.deepcopy(self)

        if corr_thresh == 1.0:
            # no filtering
            return sig_matrix

        signatures = sig_matrix.signatures
        matrix = sig_matrix.expression_matrix

        # sort signatures first by PC, then by E-score
        sig_abs_pcs = np.absolute(np.int64([sig.pc for sig in signatures]))
        sig_escore = np.float64([sig.escore for sig in signatures])
        a = np.lexsort([-sig_escore, sig_abs_pcs])

        # filtering
        S = matrix.values
        q, n = matrix.shape
        sel = np.ones(q, dtype=np.bool_)
        for i in a:

            if not sel[i]:
                # already excluded
                continue

            for i2, sig in enumerate(signatures):
                if i == i2 or not sel[i2]:
                    continue
                # assert np.corrcoef(np.vstack([S[i,:],S[i2,:]])).shape == (2,2)
                if np.corrcoef(np.vstack([S[i, :], S[i2, :]]))[0, 1] >= \
                        corr_thresh:
                    logger.info(
                        'Excluding signature "%s" due to correlation with '
                        '"%s".',
                        signatures[i2].label, signatures[i].label)
                    sel[i2] = False

        sel = np.nonzero(sel)[0]
        sig_matrix.signatures = [sig_matrix.signatures[i] for i in sel]
        return sig_matrix

    def write_pickle(self, path):
        """Save the current object to a pickle file.

        Parameters
        ----------
        path: str
            The path of the pickle file.

        Returns
        -------
        None
        """
        logger.info('Writing GO-PCA result to pickle file "%s"...', path)
        with open(path, 'wb') as ofh:
            pickle.dump(self, ofh, pickle.HIGHEST_PROTOCOL)
