# Copyright (c) 2015, 2016 Florian Wagner
#
# This file is part of GO-PCA.
#
# GO-PCA is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""Module containing the `GOPCAResult` class.
"""

from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from builtins import *

import logging
import hashlib
import copy
import six

import numpy as np

from genometools.expression import ExpMatrix
from genometools.expression import cluster

from gopca import GOPCAConfig, GOPCASignature
from gopca import util

if six.PY2:
    import cPickle as pickle
else:
    import pickle
logger = logging.getLogger(__name__)


class GOPCAResult(object):
    """Class representing a GO-PCA result.

    Parameters
    ----------
    config: `GOPCAConfig`
        The GO-PCA configuration used.
    genes: tuple or list
        The list of genes in the analysis.
    samples: tuple or list
        The list of sample labels in the analysis.
    W: `numpy.ndarray`
        The PCA loading matrix; shape = (len(genes) x # PCs).
    Y: `numpy.ndarray`
        The PC score matrix; shape = (len(samples) x # PCs).
    signatures: list or tuple of `go_pca.GOPCASignature`
        The GO-PCA signatures.
    S: `numpy.ndarray`
        The GO-PCA signature matrix; shape = (len(signatures) x len(samples)).
    """

    def __init__(self, config, genes, samples, W, Y, signatures, S):
        # W = PCA loading matrix
        # Y = PCA score matrix
        # S = GO-PCA signature matrix

        assert isinstance(config, GOPCAConfig)
        assert isinstance(genes, (list, tuple))
        for g in genes:
            assert isinstance(g, str)
        assert isinstance(samples, (list, tuple))
        for s in samples:
            assert isinstance(s, str)
        assert isinstance(W, np.ndarray)
        assert isinstance(Y, np.ndarray)
        assert isinstance(signatures, (list, tuple))
        for s in signatures:
            assert isinstance(s, GOPCASignature)
        assert isinstance(S, np.ndarray)

        assert W.shape[0] == len(genes)
        assert Y.shape[0] == len(samples)
        assert W.shape[1] == Y.shape[1]
        assert S.shape[0] == len(signatures)

        self.config = copy.deepcopy(config)

        self.genes = tuple(genes)
        self.samples = tuple(samples)
        self.W = W
        self.Y = Y

        self.signatures = tuple(signatures)
        self.S = S

    # magic functions
    def __repr__(self):
        return '<GOPCAResult: %d signatures (hash=%d)>' % (self.q, hash(self))

    def __str__(self):
        param_str = 'data: %d genes, %d samples, %d PCs tested' \
                    % (self.p, self.n, self.D)

        return '<GOPCAReult with %d signatures (%s)>' \
               % (self.q, param_str)

    def __eq__(self, other):
        if self is other:
            return True
        elif type(self) != type(other):
            return False
        else:
            return repr(self) == repr(other)

    def __ne__(self, other):
        return not (self == other)

    # def __deepcopy__(self, memo):
    #     
    #    #config = copy.deepcopy(self.config)
    #    cp.set_params(self.__params)
    #    return cp

    def __hash__(self):
        # internal hash function
        data = (
            self.signatures,
            self.samples,
            self.S.tobytes(),
            self.genes,
            self.W.tobytes(),
            self.Y.tobytes(),
        )
        return hash(data)

    # def __setstate__(self, d):
    #    # called upon unpickling
    #    self.__dict__ = d

    def get_signature(self, name, pc=None, i=None):
        # find all signatures that start with name and (optionally)
        # were generated by a certain PC

        # type checks
        assert isinstance(name, str)
        if pc is not None:
            assert isinstance(pc, int) and pc >= 1
        if i is not None:
            assert isinstance(i, int)

        if i is None:
            i = 0

        found = []
        for sig in self.signatures:
            if sig.gene_set.name.startswith(name):
                if pc is None or abs(sig.pc) == pc:
                    found.append(sig)

        if not found:
            raise ValueError('Signature not found!')

        if i >= len(found):
            raise ValueError('Index "%d" out of bounds.' % i)

        return found[i]

    def get_hash(self):
        """Calculate MD5 hash value for the result.

        The configuration data is excluded from the hash value calculation.

        Parameters
        ----------

        Returns
        -------
        str
            The MD5 hash value (as hex string).
        """
        data = str(hash(self)).encode('ascii')
        h = str(hashlib.md5(data).hexdigest())
        return h

    @property
    def signature_labels(self):
        sig_labels = self.get_signature_labels()
        return sig_labels

    @property
    def signature_matrix(self):
        """Return the signature matrix as an ExpMatrix."""
        S, _, _ = self.get_signature_matrix()
        return S

    def get_signature_labels(
            self, max_name_length=50, include_id=False):
        assert isinstance(max_name_length, int)

        # generate signature labels
        sig_labels = [
            sig.get_label(max_name_length=max_name_length,
                          include_id=include_id)
            for sig in self.signatures
        ]

        return sig_labels

    def get_signature_matrix(
            self, max_name_length=50, include_id=False,
            cluster_signatures=True,
            signature_cluster_metric='correlation',
            cluster_samples=True,
            sample_cluster_metric='euclidean',
            cluster_method='average'):
        """Return the signature matrix as an ExpMatrix."""

        assert isinstance(max_name_length, int)

        # generate signature labels
        sig_labels = self.get_signature_labels(max_name_length=max_name_length,
                                               include_id=include_id)

        # generate the signature expression matrix
        S = ExpMatrix(genes=sig_labels, samples=self.samples, X=self.S,
                      copy=True)

        order_signatures = None
        if cluster_signatures:
            # cluster signatures
            S, order_signatures = cluster.cluster_genes(
                S, metric=signature_cluster_metric, method=cluster_method
            )

        order_samples = None
        if cluster_samples:
            # cluster samples
            S, order_samples = cluster.cluster_samples(
                    S, metric=sample_cluster_metric, method=cluster_method
            )
       
        return S, order_signatures, order_samples

    @property
    def p(self):
        """The number of genes in the analysis."""
        return len(self.genes)

    @property
    def n(self):
        """The number of samples in the analysis."""
        return len(self.samples)

    @property
    def D(self):
        """The number of principal components tested."""
        return self.W.shape[1]

    @property
    def q(self):
        """The number of signatures generated."""
        return len(self.signatures)

    def filter_signatures(self, corr_thresh):
        """Filter the signatures generated based on their correlations."""
        filt = copy.copy(self)
        
        signatures, S = util.filter_signatures(filt.signatures, filt.S,
                                               corr_thresh=corr_thresh)
        filt.signatures = signatures
        filt.S = S
        return filt

    def write_pickle(self, path):
        """Save the current object to a pickle file.

        Parameters
        ----------
        path: str
            The path of the pickle file.

        Returns
        -------
        None
        """
        logger.info('Writing GO-PCA result to pickle file "%s"...', path)
        with open(path, 'wb') as ofh:
            pickle.dump(self, ofh, pickle.HIGHEST_PROTOCOL)
